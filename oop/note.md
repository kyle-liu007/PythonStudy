# 类和对象的成员分析
- 类和对象都可存储成员,成员可以归类所有,也可归对象所有
- 类存储成员时使用的是与它相关联的一个对象
- 对象储存成员时储存在当前对象中
- 对象访问一个成员时,如果对象中没有该成员,尝试访问类中的
    同名成员,如果对象中有此成员,一定使用对象中的成员
- 创建对象的时候,类中的成员不会放入对象当中,而是得到一个
    空对象，没有成员
- 通过对象对类中成员重新赋值或添加新成员时,对应成员会保
    存在对象中,而不会修改类成员
    
# 关于self
- 方法中有self形参的方法为非绑定类的方法，可以通过对象
    访问，没有self的是绑定类的方法，只能通过类访问
- 使用类访问绑定类的方法时,如果类方法中需要访问当前类的
    成员,可以通过 __class__ 成语名来访问
    
# 类的三大特性
- 封装
- 继承
- 多态

# 封装
- 封装就是对对象的成员进行访问限制
- 封装的三个级别：
    - 公开：public
    - 受保护的：protected
    - 私有的：private
    - public,private,protected不是关键字
- 判别对象的位置
    - 对象内部
    - 对象外部
    - 子类中
- 私有
    - 私有成员时最高级别的封装,只能在当前类或对象中访问
    - 在成员前面添加两个下划线即可
    
        class Person():
        #name是共有成员
        name = "liu"
        #age是私有成员
        __age = 18
    
    - Python的私有不是真私有,是一种成为name mangling
        的该名策略,可以使用对象._classname__attributename访问

- 受保护的封装 protected
    - 受保护的封装是将对象成员进行一定级别的分装,在类后者子类中都可
        以进行访问，但是在外部不行
    - 封装方法：在成员名称前添加一个下划线

- 公开    

# supper
    - supper不是关键字,而是关键字
    - super的作用是获取MRO（MethodResolutionOrder)列表中的第一个类(类名.__mro__ 是获取该类的父类的函数)
    - super与父类没有直接的的实质性关系,但通过super可以调用到父类
    
# 常用魔术方法
    - 魔术方法就是不需要人为调用的方法，基本时在特定的时刻自动触发
    - 魔术方法的统一特征：方法名被前后各两个下划线包裹
    - 操作类：
        - \_\_init__:构造函数
        - \_\_new__: 对象实例化方法,此函数比较特殊，一般不需要使用
        - \_\_call__：将对象作为函数使用的时候触发
        - \_\_str__:将对象作为字符串使用时触发
        - \_\_repr__:与__str__差不多
    - 描述付相关：
        - \_\_set__
        - \_\_get__
        - \_\_delete__
    - 属性操作相关：
        - \_\_getattr__（self,attr）:当类中没有给定的成员属性时触发
            - 形参：self用于获取对象名.attr用于获取给定成员属性
        - \_\_setattr__(self, attr, value):对成员属性进行设置的时候触发
            - 注意：不得直接赋值,否则导致死循环,为跳出死循环,规定使用
                父类魔法函数
    - 运算类相关魔法函数：
        - \_\_gt__(self1,self2):进行大于判断时触发的函数
            - 注意：字符串的比较遵循Unicode码,从第一个字符开始比较,
                谁的Unicode的码大,谁就大,一旦得出结果,则不再比较后面的字符,
                否则继续下一个字符的比较

# 抽象类  
- 抽象方法的定义：没有具体实现内容的方法成为抽象方法
- 抽象方法的主要意义时规范子类的行为和接口
- 抽象类的使用需要借助abc模块
- 语法：

            import abc


            class ClassName(metaclass=abc.ABCMeta):
                '''
                定义一个抽象类
                '''
                @abc.abstractmethod
                def method(self):
                    '''
                    定义一个实例抽象方法
                    '''
                    pass
                 
                @abc.abstractclassmethod
                def classmethod(cls):
                    '''定义一个类抽象方法'''
                    pass
        
                  
                @abc.abstractstaticmethod
                def staticmrthod():
                    '''定义一个静态抽象方法'''
                    pass
            
- 包含抽象方法的类叫抽象类,通常称为ABC(abstract class)类
- 抽象类的使用：
    - 抽象类可以包含抽象方法,也可包含具体方法
    - 抽象类中可以有方法也可以有属性
    - 抽象类不允许直接实例化,且继承的子类必须实现所有继承来的抽象方法
    - 假设子类没有实现所有继承的抽象方法,则子类也不能实例化
    - 抽象类的主要作用是设定类的标准,以便于开发的时候具有统一的规范

# 创建元类
    - 语法：
        class ClassNameMateClass(type):
            def __new__(cls, name, bases, attrs):
                attrs['attr_name1'] = value
                attrs['attr_name2'] = value
                …………
                return type.__new__(cls, name, bases, attrs)
                    